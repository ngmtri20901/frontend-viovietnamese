{"version":3,"sources":["turbopack:///[project]/features/flashcards/types/flashcard.types.ts","turbopack:///[project]/features/flashcards/utils/apiClient.ts","turbopack:///[project]/features/flashcards/utils/transformers.ts","turbopack:///[project]/features/flashcards/services/flashcardService.ts"],"sourcesContent":["/**\r\n * TypeScript types for flashcard data structures\r\n * Includes both backend response types and frontend adapted types\r\n */\r\n\r\n// Backend response types (matching FastAPI FlashcardResponse)\r\nexport interface BackendFlashcardResponse {\r\n  id: string\r\n  vietnamese: string\r\n  english: string[]\r\n  type: string[] | string\r\n  is_multiword: boolean\r\n  is_multimeaning: boolean\r\n  vietnamese_sentence: string\r\n  english_sentence: string\r\n  topic: string[]\r\n  audio_url: string | null\r\n  image_url: string | null\r\n  text_complexity: string\r\n  common_class: string\r\n  selected_meaning: string[] | null\r\n  common_meaning: string\r\n  pronunciation?: string\r\n}\r\n\r\nexport interface BackendTopicResponse {\r\n  id: string\r\n  title: string\r\n  description: string\r\n  count: number\r\n  imageUrl: string | null\r\n}\r\n\r\nexport interface FlashcardSearchResponse {\r\n  flashcards: BackendFlashcardResponse[]\r\n  total: number\r\n  skip: number\r\n  limit: number\r\n  has_more: boolean\r\n}\r\n\r\n// Frontend adapted types (for components)\r\nexport interface FlashcardData {\r\n  id: string\r\n  vietnamese: string\r\n  english: string[]\r\n  type: string[] | string\r\n  is_multiword: boolean\r\n  is_multimeaning: boolean\r\n  common_meaning: string\r\n  vietnamese_sentence: string\r\n  english_sentence: string\r\n  topic: string[]\r\n  is_common: boolean\r\n  image_url: string | null\r\n  audio_url: string | null\r\n  pronunciation?: string\r\n  // Saved flashcard metadata\r\n  saved_id?: string\r\n  saved_at?: string\r\n  flashcard_type?: 'APP' | 'CUSTOM'\r\n  tags?: string[]\r\n  review_count?: number\r\n  last_reviewed?: string\r\n  notes?: string\r\n  is_favorite?: boolean\r\n  // Custom flashcard specific fields\r\n  ipa_pronunciation?: string\r\n}\r\n\r\nexport interface FlashcardTopic {\r\n  id: string\r\n  title: string\r\n  description: string\r\n  count: number\r\n  imageUrl: string\r\n}\r\n\r\nexport interface WordType {\r\n  id: string\r\n  name: string\r\n  title: string\r\n  description: string\r\n  count: number\r\n  imageUrl: string\r\n}\r\n\r\nexport interface RandomFlashcardParams {\r\n  count?: number\r\n  commonWordsOnly?: boolean\r\n}\r\n\r\n// API Error class\r\nexport class APIError extends Error {\r\n  constructor(public status: number, message: string) {\r\n    super(message)\r\n    this.name = \"APIError\"\r\n  }\r\n}\r\n\r\n","/**\r\n * API client utility for making requests to the FastAPI backend\r\n */\r\n\r\nimport { APIError } from '../types/flashcard.types'\r\n\r\n// Configuration\r\nexport const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000\"\r\nexport const API_PREFIX = \"/api/v1\"\r\n\r\n// Helper function to handle API responses\r\nexport async function apiRequest<T>(endpoint: string, options?: RequestInit): Promise<T> {\r\n  const url = `${API_BASE_URL}${API_PREFIX}${endpoint}`\r\n  \r\n  try {\r\n    const response = await fetch(url, {\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        ...options?.headers,\r\n      },\r\n      cache: 'no-store', // Prevent browser and Next.js caching for fresh data\r\n      ...options,\r\n    })\r\n\r\n    if (!response.ok) {\r\n      throw new APIError(response.status, `API request failed: ${response.statusText}`)\r\n    }\r\n\r\n    return await response.json()\r\n  } catch (error) {\r\n    if (error instanceof APIError) {\r\n      throw error\r\n    }\r\n    throw new APIError(0, `Network error: ${error instanceof Error ? error.message : \"Unknown error\"}`)\r\n  }\r\n}\r\n\r\n","/**\r\n * Data transformation utilities\r\n * Converts backend response types to frontend types\r\n */\r\n\r\nimport type { BackendFlashcardResponse, BackendTopicResponse, FlashcardData, FlashcardTopic } from '../types/flashcard.types'\r\n\r\n/**\r\n * Converts a relative image path to a full Supabase Storage URL\r\n * Handles both relative paths (e.g., \"flashcards/filename.jpg\") and full URLs (backward compatibility)\r\n */\r\nexport function getImageUrl(imagePath: string | null | undefined): string | null {\r\n  if (!imagePath) return null\r\n\r\n  // If already a full URL, return as-is (backward compatibility)\r\n  if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {\r\n    return imagePath\r\n  }\r\n\r\n  // Convert relative path to full Supabase Storage URL\r\n  // Format: {SUPABASE_URL}/storage/v1/object/public/{bucket}/{path}\r\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\r\n  if (!supabaseUrl) {\r\n    console.warn('NEXT_PUBLIC_SUPABASE_URL is not configured')\r\n    return imagePath // Return relative path as fallback\r\n  }\r\n\r\n  // Remove leading slash if present\r\n  const cleanPath = imagePath.startsWith('/') ? imagePath.slice(1) : imagePath\r\n\r\n  // Construct full URL for the 'images' bucket\r\n  return `${supabaseUrl}/storage/v1/object/public/images/${cleanPath}`\r\n}\r\n\r\n// Transform backend flashcard response to frontend flashcard data\r\nexport function transformBackendFlashcard(backend: any): FlashcardData {\r\n  return {\r\n    id: backend.id,\r\n    vietnamese: backend.vietnamese,\r\n    english: backend.english,\r\n    type: backend.type,\r\n    is_multiword: backend.is_multiword,\r\n    is_multimeaning: backend.is_multimeaning,\r\n    common_meaning: backend.common_meaning,\r\n    vietnamese_sentence: backend.vietnamese_sentence,\r\n    english_sentence: backend.english_sentence,\r\n    topic: backend.topic,\r\n    is_common: backend.common_class === \"common\",\r\n    image_url: backend.image_url,\r\n    audio_url: backend.audio_url,\r\n    pronunciation: backend.pronunciation,\r\n    // Handle saved flashcard metadata\r\n    saved_id: backend.saved_id,\r\n    saved_at: backend.saved_at,\r\n    flashcard_type: backend.flashcard_type,\r\n    tags: backend.tags,\r\n    review_count: backend.review_count,\r\n    last_reviewed: backend.last_reviewed,\r\n    notes: backend.notes,\r\n    is_favorite: backend.is_favorite,\r\n    ipa_pronunciation: backend.ipa_pronunciation,\r\n  }\r\n}\r\n\r\n// Transform backend topic response to frontend topic data\r\nexport function transformBackendTopic(backend: BackendTopicResponse): FlashcardTopic {\r\n  return {\r\n    id: backend.id,\r\n    title: backend.title,\r\n    description: backend.description,\r\n    count: backend.count,\r\n    imageUrl: backend.imageUrl || \"/placeholder.svg?height=200&width=400\",\r\n  }\r\n}\r\n\r\n","/**\r\n * Flashcard API service layer\r\n * Connects frontend to FastAPI backend\r\n */\r\n\r\nimport type {\r\n  BackendFlashcardResponse,\r\n  BackendTopicResponse,\r\n  FlashcardSearchResponse,\r\n  FlashcardData,\r\n  FlashcardTopic,\r\n  WordType,\r\n  RandomFlashcardParams,\r\n} from '../types/flashcard.types'\r\nimport { apiRequest } from '../utils/apiClient'\r\nimport { transformBackendFlashcard, transformBackendTopic } from '../utils/transformers'\r\n\r\n// API service object with all methods\r\nexport const flashcardAPI = {\r\n  // Get all flashcards with pagination\r\n  async getAllFlashcards(skip = 0, limit = 100): Promise<FlashcardData[]> {\r\n    const response = await apiRequest<BackendFlashcardResponse[]>(\r\n      `/flashcards?skip=${skip}&limit=${limit}`\r\n    )\r\n    return response.map(transformBackendFlashcard)\r\n  },\r\n\r\n  // Get random flashcards for daily practice\r\n  async getRandomFlashcards({ count = 20, commonWordsOnly = false }: RandomFlashcardParams = {}): Promise<FlashcardData[]> {\r\n    const searchParams = new URLSearchParams({\r\n      count: String(count),\r\n      common_words_only: String(commonWordsOnly),\r\n    })\r\n\r\n    const response = await apiRequest<BackendFlashcardResponse[]>(\r\n      `/flashcards/random?${searchParams.toString()}`\r\n    )\r\n    return response.map(transformBackendFlashcard)\r\n  },\r\n\r\n  // Search flashcards\r\n  async searchFlashcards(query: string, limit = 50): Promise<FlashcardData[]> {\r\n    const response = await apiRequest<BackendFlashcardResponse[]>(\r\n      `/flashcards/search?q=${encodeURIComponent(query)}&limit=${limit}`\r\n    )\r\n    return response.map(transformBackendFlashcard)\r\n  },\r\n\r\n  // Get all topics\r\n  async getAllTopics(complexity?: string): Promise<FlashcardTopic[]> {\r\n    const url = complexity ? `/flashcards/topics?complexity=${encodeURIComponent(complexity)}` : \"/flashcards/topics\"\r\n    const response = await apiRequest<BackendTopicResponse[]>(url)\r\n    return response.map(transformBackendTopic)\r\n  },\r\n\r\n  // Get flashcards by topic with pagination\r\n  async getFlashcardsByTopic(topicId: string, complexity?: string, skip = 0, limit = 20): Promise<{flashcards: FlashcardData[], total: number, hasMore: boolean}> {\r\n    // First get all topics to find the title for this ID\r\n    const topics = await this.getAllTopics()\r\n    const topic = topics.find(t => t.id === topicId)\r\n    \r\n    if (!topic) {\r\n      console.warn(`Topic not found for ID: ${topicId}`)\r\n      return {flashcards: [], total: 0, hasMore: false}\r\n    }\r\n    \r\n    // Build URL with pagination and optional complexity parameter\r\n    const params = new URLSearchParams({\r\n      skip: skip.toString(),\r\n      limit: limit.toString()\r\n    })\r\n    \r\n    if (complexity) {\r\n      params.append('complexity', complexity)\r\n    }\r\n    \r\n    const url = `/flashcards/by-topic/${encodeURIComponent(topic.title)}?${params.toString()}`\r\n    \r\n    const response = await apiRequest<FlashcardSearchResponse>(url)\r\n    return {\r\n      flashcards: response.flashcards.map(transformBackendFlashcard),\r\n      total: response.total,\r\n      hasMore: response.has_more\r\n    }\r\n  },\r\n\r\n  // Get flashcards by topic (legacy method for backward compatibility)\r\n  async getFlashcardsByTopicLegacy(topicId: string, complexity?: string): Promise<FlashcardData[]> {\r\n    const result = await this.getFlashcardsByTopic(topicId, complexity, 0, 1000)\r\n    return result.flashcards\r\n  },\r\n\r\n  // Get flashcards by word type\r\n  async getFlashcardsByType(wordType: string, complexity?: string): Promise<FlashcardData[]> {\r\n    const url = complexity\r\n      ? `/flashcards/by-type/${encodeURIComponent(wordType)}?complexity=${encodeURIComponent(complexity)}`\r\n      : `/flashcards/by-type/${encodeURIComponent(wordType)}`\r\n    \r\n    const response = await apiRequest<BackendFlashcardResponse[]>(url)\r\n    return response.map(transformBackendFlashcard)\r\n  },\r\n\r\n  // Get multi-word expression flashcards\r\n  async getMultiwordFlashcards(complexity?: string): Promise<FlashcardData[]> {\r\n    const url = complexity\r\n      ? `/flashcards/multiword?complexity=${encodeURIComponent(complexity)}`\r\n      : \"/flashcards/multiword\"\r\n    \r\n    const response = await apiRequest<BackendFlashcardResponse[]>(url)\r\n    return response.map(transformBackendFlashcard)\r\n  },\r\n\r\n  // Get multi-meaning flashcards\r\n  async getMultimeaningFlashcards(complexity?: string): Promise<FlashcardData[]> {\r\n    const url = complexity\r\n      ? `/flashcards/multimeaning?complexity=${encodeURIComponent(complexity)}`\r\n      : \"/flashcards/multimeaning\"\r\n    \r\n    const response = await apiRequest<BackendFlashcardResponse[]>(url)\r\n    return response.map(transformBackendFlashcard)\r\n  },\r\n\r\n  // Get flashcards by complexity\r\n  async getFlashcardsByComplexity(complexity: string, skip = 0, limit = 100): Promise<FlashcardData[]> {\r\n    const response = await apiRequest<BackendFlashcardResponse[]>(\r\n      `/flashcards/by-complexity/${encodeURIComponent(complexity)}?skip=${skip}&limit=${limit}`\r\n    )\r\n    return response.map(transformBackendFlashcard)\r\n  },\r\n\r\n  // Get complexity counts\r\n  async getComplexityCounts(): Promise<{all: number, simple: number, complex: number}> {\r\n    const response = await apiRequest<{all: number, simple: number, complex: number}>(\"/flashcards/complexity-counts\")\r\n    return response\r\n  },\r\n\r\n  // Get single flashcard by ID\r\n  async getFlashcardById(id: string): Promise<FlashcardData> {\r\n    const response = await apiRequest<BackendFlashcardResponse>(`/flashcards/${id}`)\r\n    return transformBackendFlashcard(response)\r\n  },\r\n\r\n  // Get flashcard audio URL\r\n  async getFlashcardAudio(flashcardId: string): Promise<{flashcard_id: string, audio_url: string | null, vietnamese: string}> {\r\n    const response = await apiRequest<{flashcard_id: string, audio_url: string | null, vietnamese: string}>(\r\n      `/flashcards/${flashcardId}/audio`\r\n    )\r\n    return response\r\n  },\r\n\r\n  // Health check\r\n  async healthCheck(): Promise<{ status: string }> {\r\n    return await apiRequest<{ status: string }>(\"/flashcards/health\")\r\n  },\r\n\r\n  // Get all word types\r\n  async getAllWordTypes(complexity?: string): Promise<WordType[]> {\r\n    const url = complexity ? `/flashcards/word-types?complexity=${encodeURIComponent(complexity)}` : \"/flashcards/word-types\"\r\n    const response = await apiRequest<WordType[]>(url)\r\n    return response\r\n  },\r\n\r\n  // Get others counts (multi-meaning and multi-word)\r\n  async getOthersCounts(complexity?: string): Promise<{multiword: number, multimeaning: number}> {\r\n    const url = complexity ? `/flashcards/others-counts?complexity=${encodeURIComponent(complexity)}` : \"/flashcards/others-counts\"\r\n    const response = await apiRequest<{multiword: number, multimeaning: number}>(url)\r\n    return response\r\n  },\r\n\r\n  // Get flashcards by word type with pagination\r\n  async getFlashcardsByTypeWithPagination(wordType: string, complexity?: string, skip = 0, limit = 20): Promise<{flashcards: FlashcardData[], total: number, hasMore: boolean}> {\r\n    const params = new URLSearchParams({\r\n      skip: skip.toString(),\r\n      limit: limit.toString(),\r\n    })\r\n    \r\n    if (complexity) {\r\n      params.append('complexity', complexity)\r\n    }\r\n    \r\n    const response = await apiRequest<FlashcardSearchResponse>(`/flashcards/by-type/${encodeURIComponent(wordType)}?${params}`)\r\n    \r\n    return {\r\n      flashcards: response.flashcards.map(transformBackendFlashcard),\r\n      total: response.total,\r\n      hasMore: response.has_more\r\n    }\r\n  },\r\n\r\n  // Get multi-word flashcards with pagination\r\n  async getMultiwordFlashcardsWithPagination(complexity?: string, skip = 0, limit = 20): Promise<{flashcards: FlashcardData[], total: number, hasMore: boolean}> {\r\n    const params = new URLSearchParams({\r\n      skip: skip.toString(),\r\n      limit: limit.toString(),\r\n    })\r\n    \r\n    if (complexity) {\r\n      params.append('complexity', complexity)\r\n    }\r\n    \r\n    const response = await apiRequest<FlashcardSearchResponse>(`/flashcards/multiword?${params}`)\r\n    \r\n    return {\r\n      flashcards: response.flashcards.map(transformBackendFlashcard),\r\n      total: response.total,\r\n      hasMore: response.has_more\r\n    }\r\n  },\r\n\r\n  // Get multi-meaning flashcards with pagination\r\n  async getMultimeaningFlashcardsWithPagination(complexity?: string, skip = 0, limit = 20): Promise<{flashcards: FlashcardData[], total: number, hasMore: boolean}> {\r\n    const params = new URLSearchParams({\r\n      skip: skip.toString(),\r\n      limit: limit.toString(),\r\n    })\r\n\r\n    if (complexity) {\r\n      params.append('complexity', complexity)\r\n    }\r\n\r\n    const response = await apiRequest<FlashcardSearchResponse>(`/flashcards/multimeaning?${params}`)\r\n\r\n    return {\r\n      flashcards: response.flashcards.map(transformBackendFlashcard),\r\n      total: response.total,\r\n      hasMore: response.has_more\r\n    }\r\n  },\r\n\r\n  // Get user's saved flashcards\r\n  async getSavedFlashcards(userId: string): Promise<{flashcards: FlashcardData[], total: number}> {\r\n    const response = await apiRequest<{flashcards: any[], total: number}>(`/flashcards/saved/${userId}`)\r\n    return {\r\n      flashcards: response.flashcards.map(transformBackendFlashcard),\r\n      total: response.total\r\n    }\r\n  },\r\n\r\n  // Get saved flashcards count\r\n  async getSavedFlashcardsCount(userId: string): Promise<{count: number}> {\r\n    const response = await apiRequest<{count: number}>(`/flashcards/saved/${userId}/count`)\r\n    return response\r\n  },\r\n\r\n  // Get flashcards by IDs\r\n  async getFlashcardsByIds(flashcardIds: string[]): Promise<FlashcardData[]> {\r\n    const response = await apiRequest<BackendFlashcardResponse[]>(`/flashcards/by-ids`, {\r\n      method: 'POST',\r\n      body: JSON.stringify(flashcardIds)\r\n    })\r\n    return response.map(transformBackendFlashcard)\r\n  },\r\n}\r\n\r\n// Export individual functions for backward compatibility\r\nexport async function getAllFlashcards(): Promise<FlashcardData[]> {\r\n  return flashcardAPI.getAllFlashcards()\r\n}\r\n\r\nexport async function getAllTopics(): Promise<FlashcardTopic[]> {\r\n  return flashcardAPI.getAllTopics()\r\n}\r\n\r\nexport async function getAllWordTypes(): Promise<WordType[]> {\r\n  return flashcardAPI.getAllWordTypes()\r\n}\r\n\r\nexport async function getFlashcardsByTopic(topicId: string, complexity?: string): Promise<{ flashcards: FlashcardData[]; title: string }> {\r\n  // Define special categories at function scope\r\n  const specialCategories = ['multi-meaning', 'multi-word']\r\n  \r\n  // Define word types that should use the by-type endpoint - get this dynamically from backend\r\n  try {\r\n    const allWordTypes = await flashcardAPI.getAllWordTypes()\r\n    const wordTypeIds = allWordTypes.map(wt => wt.id)\r\n    \r\n    // Check if this is a word type\r\n    if (wordTypeIds.includes(topicId.toLowerCase())) {\r\n      const wordType = allWordTypes.find(wt => wt.id === topicId.toLowerCase())\r\n      if (wordType) {\r\n        const flashcards = await flashcardAPI.getFlashcardsByType(wordType.name, complexity)\r\n        return {\r\n          flashcards,\r\n          title: wordType.title,\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Check if this is a special category\r\n    if (specialCategories.includes(topicId.toLowerCase())) {\r\n      let flashcards: FlashcardData[]\r\n      let title: string\r\n      \r\n      if (topicId.toLowerCase() === 'multi-meaning') {\r\n        flashcards = await flashcardAPI.getMultimeaningFlashcards(complexity)\r\n        title = 'Multi-meaning Words'\r\n      } else if (topicId.toLowerCase() === 'multi-word') {\r\n        flashcards = await flashcardAPI.getMultiwordFlashcards(complexity)\r\n        title = 'Multi-word Expressions'\r\n      } else {\r\n        flashcards = []\r\n        title = topicId\r\n      }\r\n      \r\n      return {\r\n        flashcards,\r\n        title,\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error loading word types:\", error)\r\n    // Fallback to hardcoded list if API fails\r\n    const wordTypes = ['verb', 'noun', 'adj', 'adv', 'prep', 'conj', 'intj', 'pron', 'num', 'det', 'part']\r\n    \r\n    // Check if this is a word type\r\n    if (wordTypes.includes(topicId.toLowerCase())) {\r\n      const wordType = topicId.toUpperCase() // Backend expects uppercase\r\n      const flashcards = await flashcardAPI.getFlashcardsByType(wordType, complexity)\r\n      \r\n      // Create proper title for word types\r\n      const titleMap: Record<string, string> = {\r\n        'VERB': 'Verbs',\r\n        'NOUN': 'Nouns', \r\n        'ADJ': 'Adjectives',\r\n        'ADV': 'Adverbs',\r\n        'PREP': 'Prepositions',\r\n        'CONJ': 'Conjunctions',\r\n        'INTJ': 'Interjections',\r\n        'PRON': 'Pronouns',\r\n        'NUM': 'Numbers',\r\n        'DET': 'Determiners',\r\n        'PART': 'Particles'\r\n      }\r\n      \r\n      return {\r\n        flashcards,\r\n        title: titleMap[wordType] || wordType,\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Check if this is a special category\r\n  if (specialCategories.includes(topicId.toLowerCase())) {\r\n    let flashcards: FlashcardData[]\r\n    let title: string\r\n    \r\n    if (topicId.toLowerCase() === 'multi-meaning') {\r\n      flashcards = await flashcardAPI.getMultimeaningFlashcards(complexity)\r\n      title = 'Multi-meaning Words'\r\n    } else if (topicId.toLowerCase() === 'multi-word') {\r\n      flashcards = await flashcardAPI.getMultiwordFlashcards(complexity)\r\n      title = 'Multi-word Expressions'\r\n    } else {\r\n      flashcards = []\r\n      title = topicId\r\n    }\r\n    \r\n    return {\r\n      flashcards,\r\n      title,\r\n    }\r\n  }\r\n  \r\n  // Otherwise, handle as regular topic\r\n  const result = await flashcardAPI.getFlashcardsByTopicLegacy(topicId, complexity)\r\n  const topics = await flashcardAPI.getAllTopics()\r\n  const topic = topics.find(t => t.id === topicId)\r\n  \r\n  return {\r\n    flashcards: result,\r\n    title: topic?.title || `Topic: ${topicId}`,\r\n  }\r\n}\r\n\r\nexport async function getFlashcardsByTopicWithPagination(\r\n  topicId: string, \r\n  complexity?: string, \r\n  skip = 0, \r\n  limit = 20\r\n): Promise<{ flashcards: FlashcardData[]; title: string; total: number; hasMore: boolean }> {\r\n  try {\r\n    const result = await flashcardAPI.getFlashcardsByTopic(topicId, complexity, skip, limit)\r\n    const topics = await flashcardAPI.getAllTopics()\r\n    const topic = topics.find(t => t.id === topicId)\r\n    \r\n    return {\r\n      flashcards: result.flashcards,\r\n      title: topic?.title || `Topic: ${topicId}`,\r\n      total: result.total,\r\n      hasMore: result.hasMore\r\n    }\r\n  } catch (error) {\r\n    console.error('Error fetching flashcards by topic with pagination:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n// Generic function to get flashcards by category ID (auto-detects type and uses pagination)\r\nexport async function getFlashcardsByCategoryWithPagination(\r\n  categoryId: string, \r\n  complexity?: string, \r\n  skip = 0, \r\n  limit = 20\r\n): Promise<{ flashcards: FlashcardData[]; title: string; total: number; hasMore: boolean }> {\r\n  try {\r\n    // Define special categories\r\n    const specialCategories = ['multi-meaning', 'multi-word']\r\n    \r\n    // Define title map for consistent naming\r\n    const titleMap: Record<string, string> = {\r\n      'VERB': 'Verbs',\r\n      'NOUN': 'Nouns', \r\n      'ADJ': 'Adjectives',\r\n      'ADV': 'Adverbs',\r\n      'PREP': 'Prepositions',\r\n      'CONJ': 'Conjunctions',\r\n      'INTJ': 'Interjections',\r\n      'PRON': 'Pronouns',\r\n      'NUM': 'Numbers',\r\n      'DET': 'Determiners',\r\n      'PART': 'Particles'\r\n    }\r\n    \r\n    // Try to get word types from backend first\r\n    try {\r\n      const allWordTypes = await flashcardAPI.getAllWordTypes()\r\n      const wordTypeIds = allWordTypes.map(wt => wt.id)\r\n      \r\n      // Check if this is a word type\r\n      if (wordTypeIds.includes(categoryId.toLowerCase())) {\r\n        const wordType = allWordTypes.find(wt => wt.id === categoryId.toLowerCase())\r\n        if (wordType) {\r\n          const result = await flashcardAPI.getFlashcardsByTypeWithPagination(wordType.name, complexity, skip, limit)\r\n          return {\r\n            flashcards: result.flashcards,\r\n            title: wordType.title,\r\n            total: result.total,\r\n            hasMore: result.hasMore\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Error loading word types, falling back to hardcoded list:\", error)\r\n      // Fallback to hardcoded list if API fails\r\n      const wordTypes = ['verb', 'noun', 'adj', 'adv', 'prep', 'conj', 'intj', 'pron', 'num', 'det', 'part']\r\n      \r\n      if (wordTypes.includes(categoryId.toLowerCase())) {\r\n        const wordType = categoryId.toUpperCase() // Backend expects uppercase\r\n        const result = await flashcardAPI.getFlashcardsByTypeWithPagination(wordType, complexity, skip, limit)\r\n        \r\n        return {\r\n          flashcards: result.flashcards,\r\n          title: titleMap[wordType] || wordType,\r\n          total: result.total,\r\n          hasMore: result.hasMore\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Check if this is a special category\r\n    if (specialCategories.includes(categoryId.toLowerCase())) {\r\n      let result: {flashcards: FlashcardData[], total: number, hasMore: boolean}\r\n      let title: string\r\n      \r\n      if (categoryId.toLowerCase() === 'multi-meaning') {\r\n        result = await flashcardAPI.getMultimeaningFlashcardsWithPagination(complexity, skip, limit)\r\n        title = 'Multi-meaning Words'\r\n      } else if (categoryId.toLowerCase() === 'multi-word') {\r\n        result = await flashcardAPI.getMultiwordFlashcardsWithPagination(complexity, skip, limit)\r\n        title = 'Multi-word Expressions'\r\n      } else {\r\n        // Fallback\r\n        result = { flashcards: [], total: 0, hasMore: false }\r\n        title = categoryId\r\n      }\r\n      \r\n      return {\r\n        flashcards: result.flashcards,\r\n        title,\r\n        total: result.total,\r\n        hasMore: result.hasMore\r\n      }\r\n    }\r\n    \r\n    // Otherwise, handle as regular topic\r\n    const result = await flashcardAPI.getFlashcardsByTopic(categoryId, complexity, skip, limit)\r\n    const topics = await flashcardAPI.getAllTopics()\r\n    const topic = topics.find(t => t.id === categoryId)\r\n    \r\n    return {\r\n      flashcards: result.flashcards,\r\n      title: topic?.title || `Topic: ${categoryId}`,\r\n      total: result.total,\r\n      hasMore: result.hasMore\r\n    }\r\n  } catch (error) {\r\n    console.error('Error fetching flashcards by category with pagination:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n// Re-export types for convenience\r\nexport type {\r\n  FlashcardData,\r\n  FlashcardTopic,\r\n  WordType,\r\n  RandomFlashcardParams,\r\n  APIError,\r\n} from '../types/flashcard.types'\r\n\r\n"],"names":[],"mappings":"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"}